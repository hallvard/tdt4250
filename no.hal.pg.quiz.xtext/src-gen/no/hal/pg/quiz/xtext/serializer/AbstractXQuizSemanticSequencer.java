/*
 * generated by Xtext
 */
package no.hal.pg.quiz.xtext.serializer;

import com.google.inject.Inject;
import com.google.inject.Provider;
import no.hal.pg.quiz.model.BooleanAnswer;
import no.hal.pg.quiz.model.ManyOptionsAnswer;
import no.hal.pg.quiz.model.ModelPackage;
import no.hal.pg.quiz.model.NumberAnswer;
import no.hal.pg.quiz.model.Option;
import no.hal.pg.quiz.model.QA;
import no.hal.pg.quiz.model.QARef;
import no.hal.pg.quiz.model.Quiz;
import no.hal.pg.quiz.model.QuizPart;
import no.hal.pg.quiz.model.QuizPartRef;
import no.hal.pg.quiz.model.SingleOptionsAnswer;
import no.hal.pg.quiz.model.StringAnswer;
import no.hal.pg.quiz.model.StringQuestion;
import no.hal.pg.quiz.model.Xml;
import no.hal.pg.quiz.model.XmlAnswer;
import no.hal.pg.quiz.model.XmlAttribute;
import no.hal.pg.quiz.model.XmlContents;
import no.hal.pg.quiz.model.XmlPIAnswerElement;
import no.hal.pg.quiz.model.XmlQuestion;
import no.hal.pg.quiz.model.XmlTag;
import no.hal.pg.quiz.model.XmlTagElement;
import no.hal.pg.quiz.xtext.services.XQuizGrammarAccess;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtext.serializer.acceptor.ISemanticSequenceAcceptor;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.diagnostic.ISemanticSequencerDiagnosticProvider;
import org.eclipse.xtext.serializer.diagnostic.ISerializationDiagnostic.Acceptor;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.GenericSequencer;
import org.eclipse.xtext.serializer.sequencer.ISemanticNodeProvider.INodesForEObjectProvider;
import org.eclipse.xtext.serializer.sequencer.ISemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public abstract class AbstractXQuizSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private XQuizGrammarAccess grammarAccess;
	
	@Override
	public void createSequence(EObject context, EObject semanticObject) {
		if(semanticObject.eClass().getEPackage() == ModelPackage.eINSTANCE) switch(semanticObject.eClass().getClassifierID()) {
			case ModelPackage.BOOLEAN_ANSWER:
				sequence_BooleanAnswer(context, (BooleanAnswer) semanticObject); 
				return; 
			case ModelPackage.MANY_OPTIONS_ANSWER:
				sequence_ManyOptionsAnswer(context, (ManyOptionsAnswer) semanticObject); 
				return; 
			case ModelPackage.NUMBER_ANSWER:
				sequence_NumberAnswer(context, (NumberAnswer) semanticObject); 
				return; 
			case ModelPackage.OPTION:
				if(context == grammarAccess.getManyOptionRule()) {
					sequence_ManyOption(context, (Option) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getSingleBoxOptionRule()) {
					sequence_SingleBoxOption(context, (Option) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getSingleListOptionRule()) {
					sequence_SingleListOption(context, (Option) semanticObject); 
					return; 
				}
				else break;
			case ModelPackage.QA:
				sequence_QA(context, (QA) semanticObject); 
				return; 
			case ModelPackage.QA_REF:
				sequence_QARef(context, (QARef) semanticObject); 
				return; 
			case ModelPackage.QUIZ:
				sequence_Quiz(context, (Quiz) semanticObject); 
				return; 
			case ModelPackage.QUIZ_PART:
				if(context == grammarAccess.getAnonymousQuizPartRule()) {
					sequence_AnonymousQuizPart(context, (QuizPart) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getAbstractQuizPartRule() ||
				   context == grammarAccess.getQuizPartRule()) {
					sequence_QuizPart(context, (QuizPart) semanticObject); 
					return; 
				}
				else break;
			case ModelPackage.QUIZ_PART_REF:
				sequence_QuizPartRef(context, (QuizPartRef) semanticObject); 
				return; 
			case ModelPackage.SINGLE_OPTIONS_ANSWER:
				if(context == grammarAccess.getAnswerRule() ||
				   context == grammarAccess.getOptionsAnswerRule() ||
				   context == grammarAccess.getSingleOptionsAnswerRule()) {
					sequence_SingleBoxOptionsAnswer_SingleListOptionsAnswer_SingleOptionsAnswer(context, (SingleOptionsAnswer) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getSingleBoxOptionsAnswerRule()) {
					sequence_SingleBoxOptionsAnswer(context, (SingleOptionsAnswer) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getSingleListOptionsAnswerRule()) {
					sequence_SingleListOptionsAnswer(context, (SingleOptionsAnswer) semanticObject); 
					return; 
				}
				else break;
			case ModelPackage.STRING_ANSWER:
				if(context == grammarAccess.getAnswerRule() ||
				   context == grammarAccess.getOptionAnswerRule() ||
				   context == grammarAccess.getSimpleAnswerRule()) {
					sequence_RegexAnswer_SimpleAnswer_StringAnswer(context, (StringAnswer) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getRegexAnswerRule()) {
					sequence_RegexAnswer(context, (StringAnswer) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getStringAnswerRule()) {
					sequence_StringAnswer(context, (StringAnswer) semanticObject); 
					return; 
				}
				else break;
			case ModelPackage.STRING_QUESTION:
				sequence_StringQuestion(context, (StringQuestion) semanticObject); 
				return; 
			case ModelPackage.XML:
				sequence_Xml(context, (Xml) semanticObject); 
				return; 
			case ModelPackage.XML_ANSWER:
				sequence_XmlAnswer(context, (XmlAnswer) semanticObject); 
				return; 
			case ModelPackage.XML_ATTRIBUTE:
				sequence_XmlAttribute(context, (XmlAttribute) semanticObject); 
				return; 
			case ModelPackage.XML_CONTENTS:
				sequence_XmlContents(context, (XmlContents) semanticObject); 
				return; 
			case ModelPackage.XML_PI_ANSWER_ELEMENT:
				sequence_XmlPIAnswerElement(context, (XmlPIAnswerElement) semanticObject); 
				return; 
			case ModelPackage.XML_QUESTION:
				sequence_XmlQuestion(context, (XmlQuestion) semanticObject); 
				return; 
			case ModelPackage.XML_TAG:
				sequence_XmlTag(context, (XmlTag) semanticObject); 
				return; 
			case ModelPackage.XML_TAG_ELEMENT:
				sequence_XmlTagElement(context, (XmlTagElement) semanticObject); 
				return; 
			}
		if (errorAcceptor != null) errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Constraint:
	 *     (questions+=AbstractQA*)
	 */
	protected void sequence_AnonymousQuizPart(EObject context, QuizPart semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     ((value?='yes' | value?='true')?)
	 */
	protected void sequence_BooleanAnswer(EObject context, BooleanAnswer semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (correct?='x'? option=OptionAnswer)
	 */
	protected void sequence_ManyOption(EObject context, Option semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     options+=ManyOption+
	 */
	protected void sequence_ManyOptionsAnswer(EObject context, ManyOptionsAnswer semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (value=EDoubleObject errorMargin=EDoubleObject?)
	 */
	protected void sequence_NumberAnswer(EObject context, NumberAnswer semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     qaRef=[QA|QName]
	 */
	protected void sequence_QARef(EObject context, QARef semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ModelPackage.Literals.QA_REF__QA_REF) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelPackage.Literals.QA_REF__QA_REF));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getQARefAccess().getQaRefQAQNameParserRuleCall_1_0_1(), semanticObject.getQaRef());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (name=ID? q=Question a=Answer)
	 */
	protected void sequence_QA(EObject context, QA semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     partRef=[QuizPart|QName]
	 */
	protected void sequence_QuizPartRef(EObject context, QuizPartRef semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ModelPackage.Literals.QUIZ_PART_REF__PART_REF) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelPackage.Literals.QUIZ_PART_REF__PART_REF));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getQuizPartRefAccess().getPartRefQuizPartQNameParserRuleCall_2_0_1(), semanticObject.getPartRef());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (name=ID title=STRING questions+=AbstractQA*)
	 */
	protected void sequence_QuizPart(EObject context, QuizPart semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     ((name=QName? title=STRING? parts+=AbstractQuizPart*) | parts+=AnonymousQuizPart)
	 */
	protected void sequence_Quiz(EObject context, Quiz semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     ((value=STRING ignoreCase?='~'?) | (regexp?='/' value=STRING ignoreCase?='~'?))
	 */
	protected void sequence_RegexAnswer_SimpleAnswer_StringAnswer(EObject context, StringAnswer semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (regexp?='/' value=STRING ignoreCase?='~'?)
	 */
	protected void sequence_RegexAnswer(EObject context, StringAnswer semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (correct?='x'? option=OptionAnswer)
	 */
	protected void sequence_SingleBoxOption(EObject context, Option semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (options+=SingleBoxOption+ | options+=SingleListOption+)
	 */
	protected void sequence_SingleBoxOptionsAnswer_SingleListOptionsAnswer_SingleOptionsAnswer(EObject context, SingleOptionsAnswer semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     options+=SingleBoxOption+
	 */
	protected void sequence_SingleBoxOptionsAnswer(EObject context, SingleOptionsAnswer semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (correct?='v'? option=OptionAnswer)
	 */
	protected void sequence_SingleListOption(EObject context, Option semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     options+=SingleListOption+
	 */
	protected void sequence_SingleListOptionsAnswer(EObject context, SingleOptionsAnswer semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (value=STRING ignoreCase?='~'?)
	 */
	protected void sequence_StringAnswer(EObject context, StringAnswer semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     question=STRING
	 */
	protected void sequence_StringQuestion(EObject context, StringQuestion semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ModelPackage.Literals.STRING_QUESTION__QUESTION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelPackage.Literals.STRING_QUESTION__QUESTION));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getStringQuestionAccess().getQuestionSTRINGTerminalRuleCall_0(), semanticObject.getQuestion());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     xml=Xml
	 */
	protected void sequence_XmlAnswer(EObject context, XmlAnswer semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ModelPackage.Literals.XML_ANSWER__XML) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelPackage.Literals.XML_ANSWER__XML));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getXmlAnswerAccess().getXmlXmlParserRuleCall_0(), semanticObject.getXml());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (name=ID value=STRING)
	 */
	protected void sequence_XmlAttribute(EObject context, XmlAttribute semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ModelPackage.Literals.XML_ATTRIBUTE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelPackage.Literals.XML_ATTRIBUTE__NAME));
			if(transientValues.isValueTransient(semanticObject, ModelPackage.Literals.XML_ATTRIBUTE__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelPackage.Literals.XML_ATTRIBUTE__VALUE));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getXmlAttributeAccess().getNameIDTerminalRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getXmlAttributeAccess().getValueSTRINGTerminalRuleCall_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (element=XmlElement post=XML_TEXT)
	 */
	protected void sequence_XmlContents(EObject context, XmlContents semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ModelPackage.Literals.XML_CONTENTS__ELEMENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelPackage.Literals.XML_CONTENTS__ELEMENT));
			if(transientValues.isValueTransient(semanticObject, ModelPackage.Literals.XML_CONTENTS__POST) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelPackage.Literals.XML_CONTENTS__POST));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getXmlContentsAccess().getElementXmlElementParserRuleCall_0_0(), semanticObject.getElement());
		feeder.accept(grammarAccess.getXmlContentsAccess().getPostXML_TEXTTerminalRuleCall_1_0(), semanticObject.getPost());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     answer=SimpleAnswer
	 */
	protected void sequence_XmlPIAnswerElement(EObject context, XmlPIAnswerElement semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ModelPackage.Literals.XML_PI_ANSWER_ELEMENT__ANSWER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelPackage.Literals.XML_PI_ANSWER_ELEMENT__ANSWER));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getXmlPIAnswerElementAccess().getAnswerSimpleAnswerParserRuleCall_1_0(), semanticObject.getAnswer());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     xml=Xml
	 */
	protected void sequence_XmlQuestion(EObject context, XmlQuestion semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ModelPackage.Literals.XML_QUESTION__XML) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelPackage.Literals.XML_QUESTION__XML));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getXmlQuestionAccess().getXmlXmlParserRuleCall_0(), semanticObject.getXml());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (startTag=XmlTag (pre=XML_TEXT contents+=XmlContents* endTag=ID?)?)
	 */
	protected void sequence_XmlTagElement(EObject context, XmlTagElement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=ID attributes+=XmlAttribute*)
	 */
	protected void sequence_XmlTag(EObject context, XmlTag semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     element=XmlElement
	 */
	protected void sequence_Xml(EObject context, Xml semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ModelPackage.Literals.XML__ELEMENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelPackage.Literals.XML__ELEMENT));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getXmlAccess().getElementXmlElementParserRuleCall_1_0(), semanticObject.getElement());
		feeder.finish();
	}
}
